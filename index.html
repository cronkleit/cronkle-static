<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Play</title>
    <style>
        .item1 { grid-area: level; }
        .item8 { grid-area: time; }
        .item2 { grid-area: score; }
        .item3 { grid-area: guess; }
        .item4 { grid-area: hint; }
        .item5 { grid-area: choose; }
        .item6 { grid-area: history; }
        .item7 { grid-area: message; }

        .grid-container {
            display: grid;
            grid-template-areas:
                'level level time time score score'
                'message message message message message message'
                'guess guess guess guess guess guess'
                'hint hint hint hint hint hint'
                'choose choose choose choose choose choose'
                'history history history history history history';
            /*gap: 10px;*/
            background-color: #2196F3;
            padding: 10px;
        }

        .grid-container > div {
            /*background-color: rgba(255, 255, 255, 0.8);*/
            background-color: lightblue;
            text-align: center;
            padding: 10px 0;
            /*font-size: 30px;*/
        }

        .center {
            margin-left: auto;
            margin-right: auto;
        }

        button {
            border: none;
            background: #898D8D;
            font-weight: bold;
            color: white;
            padding: 10px;
            margin: 2px;
            border-radius: 5px;
        }

        /* The Modal (background) */
        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1; /* Sit on top */
            padding-top: 100px; /* Location of the box */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgb(0,0,0); /* Fallback color */
            background-color: rgba(200,200,200,0.8); /* Black w/ opacity */
        }

        /* Modal Content */
        .modal-content {
            background-color: #fefefe;
            margin: auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
        }

        /* The Close Button */
        .close {
            color: #aaaaaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }

        .close:hover,
        .close:focus {
            color: #000;
            text-decoration: none;
            cursor: pointer;
        }

        .row {
            display: flex;
            justify-content: center;
            margin: 5px;
        }

        .row_block {
            position: relative;
            font-size: 20px;
            border: 3px solid lightblue;
            width: 20px;
            height: 20px;
            border-radius: 12px;
            align-content: center; /* Might be necessary */
            background: white;
            font-weight: bold;
            color: black;
            padding: 15px;
            margin: 2px;
        }

        .row_block div {
            position:absolute;
            top:-5px;
            right:-5px;
            background-color:blue;
            color:#fff;
            padding:5px;
            border-radius: 12px;
            /*width:30px;*/
            /*height:30px;*/
            text-align:center;
            font-size: 15px;
        }

        .row_block_help {
            font-size: 20px;
            border: 3px solid lightblue;
            width: 20px;
            height: 20px;
            border-radius: 12px;
            align-content: center; /* Might be necessary */
            background: white;
            font-weight: bold;
            color: black;
            padding: 15px;
            margin: 2px;
        }

        /*.hint_icon {*/
        /*    font-size: 25px;*/
        /*    !*vertical-align: baseline;*!*/
        /*}*/

        .hint_circle {
            border-radius: 50%;
            padding: 0px 5px 2px 5px; /* top right bottom left */
            background-color: blue;
            color: white;
            font-weight: bold;
            font-size: 15px;
        }

        dialog::backdrop {
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px); /* For Safari */
        }

    </style>
    <script>

        const _STATE_STARTED = 1;
        const _STATE_NEXT = 2;
        const _STATE_SOLVING = 3;
        const _STATE_SOLVED = 4;
        const _STATE_EXHAUSTED = 5;
        const _STATE_EXPIRED = 6;
        const _STATE_WON = 7;

        const _PROGRESS_FIRST = '0';
        const _PROGRESS_HIT_FIRST = 'H';
        const _PROGRESS_HIT_AFTER_MISS = 'G';
        const _PROGRESS_HIT_AFTER_ALMOST = 'F';
        const _PROGRESS_ALMOST_FIRST = 'A';
        const _PROGRESS_ALMOST_AFTER_MISS = 'Z';
        const _PROGRESS_MISS = 'M';

        class Utils {

            static ham(code, position) {
                let r = 'M';
                if (position === 0) {
                    r = 'H';
                } else if (code) {
                    r = code[position];
                }
                return r;
            }

        }

        class Game {

            constructor(id, onTick, onExpired) {
                this.id = id;
                this.state = _STATE_STARTED;
                this.level = 1;
                this.round = new Round(this.level);
                this.score = 0;
                this.time = 0;
                this.attempts = 0;
                this.ticker = null;
                this.remaining = this.round.time;
                this.ontick = onTick;
                this.onexpired = onExpired;
            }

            next() {
                this.state = _STATE_NEXT;
                this.level += 1;
                this.round = new Round(this.level);
                this.remaining = this.round.time;
                return this.round;
            }

            refocus(choice) {
                let r = false;
                if (this.state === _STATE_SOLVING) {
                    this.state = _STATE_SOLVING;
                    r = this.round.refocus(choice);
                }
                return r;
            }

            choice(value) {
                this._timerStart();
                this.state = _STATE_SOLVING;
                this.round.choice(value);
            }

            guess() {
                let outcome = this.round.guess();
                this.score += outcome.points;
                this.time += this.round.time - this.remaining;
                this.attempts += 1;
                if (outcome.solved) {
                    this._timerStop();
                    let timeBonus = this.remaining;
                    let attemptsBonus = (5 - this.round.attempts) * this.level;
                    this.score += timeBonus + attemptsBonus;
                    if (this.level >= 10) {
                        this.state = _STATE_WON;
                    } else {
                        this.state = _STATE_SOLVED;
                    }
                } else if (this.round.attempts >= 5) {
                    this._timerStop();
                    this.state = _STATE_EXHAUSTED;
                }
            }

            _timerStart() {
                if (!this.ticker) {
                    this.remaining = this.round.time;
                    this.ticker = setInterval(this._timerTick.bind(this), 1000);
                }
            }

            _timerTick() {
                this.remaining--;
                if (this.remaining <= 0) {
                    this._timerStop();
                    this.state = _STATE_EXPIRED;
                    this.onexpired();
                } else {
                    this.ontick();
                }
            }

            _timerStop() {
                clearInterval(this.ticker);
                this.ticker = null;
            }

        }

        class Round {

            constructor(level) {
                this.level = level;
                this.length = this.level + 2;
                this.answer = this._answer(this.length);
                this.hint = new Hint(this.answer);
                this.focus = 1;
                this.choices = this._choices(this.answer[0], this.length);
                this.match = this._match();
                this.outcomes = [];
                this.attempts = 0;
                this.progress = [];
                this.time = 15 + ((level - 1) * 15);
            }

            refocus(choice) {
                let r = false;
                if (choice !== this.focus) {
                    let ham = this._ham(choice);
                    if (ham !== 'H') {
                        this.focus = choice;
                        r = true;
                    }
                }
                return r;
            }

            choice(value) {
                let choice = this.choices[this.focus];
                choice.chose(value);
                this.match = this._match();
                this.focus = this._refocus(this.focus);
            }

            guess() {
                const r = new Outcome(this.answer, this._code(), this.progress);
                this.outcomes.unshift(r);
                if (this.outcomes.length > 5) { this.outcomes.splice(5); }
                this.attempts += 1;
                this.choices = this._choices(this.answer[0], this.length, r);
                this.match = this._match();
                this.focus = this._refocus(0);
                return r;
            }

            solved() {
                const outcome = this.outcomes ? this.outcomes[0] : null;
                return outcome && outcome.solved;
            }

            _refocus(current) {
                let r = current;
                let next = r + 1;
                if (next === this.length) { next = 0; }
                // After current
                let found = false;
                for (let i = next; i < this.length; i++) {
                    let ham = this._ham(i);
                    if (ham !== 'H') {
                        r = i;
                        found = true;
                        break;
                    }
                }
                // From beginning (if haven't checked already)
                if (!found && (next !== 0)) {
                    for (let i = 0; i < next; i++) {
                        let ham = this._ham(i);
                        if (ham !== 'H') {
                            r = i;
                            found = true;
                            break;
                        }
                    }
                }
                return r;
            }

            _ham(position) {
                let choice = this.choices[position];
                return choice.ham;
            }

            _answer(length) {
                let r = '';
                const min = Math.ceil(0);
                const max = Math.floor(10);
                for (let i=0; i<length; i++) {
                    r += Math.floor(Math.random() * (max - min) + min);
                }
                return r;
            }

            _choices(first, length, outcome) {
                let r = new Array(length);
                for (let i=0; i<length; i++) {
                    let choice = new Choice(i);
                    if (i === 0) {
                        choice.chose(first);
                    }
                    if (outcome) {
                        choice.guessed(outcome);
                    }
                    r[i] = choice;
                }
                return r;
            }

            _match() {
                let same = 0;
                let down = 0;
                let up = 0;
                let total = 0;
                for (let i = 0; i < this.length; i++) {
                    let choice = this.choices[i];
                    let incomplete = (choice.value === -1);
                    let value = incomplete ? 0 : Number(choice.value);
                    if ((i !== 0) && !incomplete) {
                        if (this.hint.first === value) {
                            same += 1;
                        } else if (this.hint.first < value) {
                            up += 1;
                        } else {
                            down += 1;
                        }
                    }
                    total += value;
                }
                return new Match(same, down, up, total);
            }

            _code() {
                let r = '';
                for (let i = 0; i < this.length; i++) {
                    let choice = this.choices[i];
                    r += choice.value;
                }
                return r;
            }

        }

        class Hint {

            constructor(answer) {
                this.first = -1;
                this.same = 0;
                this.above = 0;
                this.below = 0;
                this.total = 0;
                this._hint(answer);
            }

            _hint(answer) {
                const answerArray = Array.from(answer);
                this.first = Number(answerArray[0]);
                for (let i=0; i<answerArray.length; i++) {
                    let nextNumeral = Number(answerArray[i]);
                    if (i > 0) {
                        if (this.first === nextNumeral) {
                            this.same += 1;
                        } else if (this.first < nextNumeral) {
                            this.above += 1;
                        } else {
                            this.below += 1;
                        }
                    }
                    this.total += nextNumeral;
                }
            }

        }

        class Choice {

            constructor(block) {
                this.block = block;
                this.value = -1;
                this.hint = -1;
                this.ham = (block === 0) ? 'H' : 'M';
            }

            chose(value) {
                this.value = Number(value);
            }

            guessed(outcome) {
                this.hint = Number(outcome.guess[this.block]);
                this.ham = Utils.ham(outcome.ham, this.block);
                if (this.ham === 'H') {
                    this.value = this.hint;
                }
            }

        }

        class Match {

            constructor(same, down, up, total) {
                this.same = same;
                this.down = down;
                this.up = up;
                this.total = total;
            }

        }

        class Outcome {

            constructor(answer, guess, progress) {
                this.guess = guess;
                this.hit = 0;
                this.almost = 0;
                this.miss = 0;
                this.ham = '';
                this.solved = false;
                this._match(answer);
                this.points = 0;
                this._progress(progress);
            }

            _match(answer) {
                const answerArray = Array.from(answer);
                const guessArray = Array.from(this.guess);
                const occurrences = this._occurrences(answerArray);
                const hits = this._hits(answerArray, guessArray);
                let almosts = new Map();
                for (let i=0; i<answerArray.length; i++) {
                    const partialAnswer = answerArray[i];
                    const partialGuess = guessArray[i];
                    if (partialAnswer === partialGuess) {
                        // HIT
                        this.hit += 1;
                        this.ham += 'H';
                    } else if (occurrences.has(partialGuess)) {
                        // Potential ALMOST
                        const occurrence = occurrences.get(partialGuess);
                        const hit = hits.has(partialGuess) ? hits.get(partialGuess) : 0;
                        let almost = almosts.has(partialGuess) ? almosts.get(partialGuess) : 0;
                        if ((occurrence - hit - almost) > 0) {
                            this.almost += 1;
                            this.ham += 'A';
                            almost += 1;
                            almosts.set(partialGuess, almost);
                        } else {
                            this.miss += 1;
                            this.ham += 'M';
                        }
                    } else {
                        // Otherwise MISS
                        this.miss += 1;
                        this.ham += 'M';
                    }
                }
                this.solved = this.hit === answerArray.length;
            }

            _occurrences(answerArray) {
                let r = new Map();
                for (let i=0; i<answerArray.length; i++) {
                    let numeral=answerArray[i];
                    let rOccurrences = r.has(numeral) ? r.get(numeral) : 0;
                    rOccurrences += 1;
                    r.set(numeral, rOccurrences);
                }
                return r;
            }

            _hits(answerArray, guessArray) {
                let r = new Map();
                for (let i=0; i<answerArray.length; i++) {
                    if (answerArray[i] === guessArray[i]) {
                        let numeral=answerArray[i];
                        let rHits = r.has(numeral) ? r.get(numeral) : 0;
                        rHits += 1;
                        r.set(numeral, rHits);
                    }
                }
                return r;
            }

            _progress(current) {
                const firstGuess = current.length === 0;
                const hamArray = Array.from(this.ham);
                for (let i=0; i<hamArray.length; i++) {
                    let nextProgress = !firstGuess ? current[i] : _PROGRESS_FIRST;
                    let nextHam = hamArray[i];
                    if (nextHam === 'H') {
                        // HIT
                        if (nextProgress === _PROGRESS_FIRST) {
                            current[i] = _PROGRESS_HIT_FIRST;
                            this.points += 2;
                        } else if (nextProgress === _PROGRESS_MISS) {
                            current[i] = _PROGRESS_HIT_AFTER_MISS;
                            this.points += 1;
                        } else if (nextProgress === _PROGRESS_ALMOST_FIRST) {
                            current[i] = _PROGRESS_HIT_AFTER_ALMOST;
                            this.points += 1;
                        } else if (nextProgress === _PROGRESS_ALMOST_AFTER_MISS) {
                            current[i] = _PROGRESS_HIT_AFTER_ALMOST;
                            this.points += 1;
                        }
                    } else if (nextHam === 'A') {
                        // ALMOST
                        if (nextProgress === _PROGRESS_FIRST) {
                            current[i] = _PROGRESS_ALMOST_FIRST;
                            this.points += 0;
                        } else if (nextProgress === _PROGRESS_MISS) {
                            current[i] = _PROGRESS_ALMOST_AFTER_MISS;
                            this.points += 0;
                        }
                    } else {
                        // MISS
                        if (nextProgress === _PROGRESS_FIRST) {
                            current[i] = _PROGRESS_MISS;
                        }
                        this.points -= 1; // It always costs to miss!
                    }
                }
            }
        }

        class GameUi {
            constructor(game) {
                this.game = game;
                this.components = [];
                this.components.push(new LevelUiComponent());
                this.components.push(new TimeUiComponent());
                this.components.push(new ScoreUiComponent());
                this.components.push(new MessageUiComponent());
                this.components.push(new GuessUiComponent());
                this.components.push(new HintUiComponent());
                this.components.push(new ChooseUiComponent());
                this.components.push(new OutcomeUiComponent());
            }
            update() {
                if (this.game.state === _STATE_STARTED) {
                    this.components.forEach(component => component.started(this.game));
                } else if (this.game.state === _STATE_NEXT) {
                    this.components.forEach(component => component.next(this.game));
                } else if (this.game.state === _STATE_SOLVING) {
                    this.components.forEach(component => component.solving(this.game));
                } else if (this.game.state === _STATE_SOLVED) {
                    this.components.forEach(component => component.solved(this.game));
                } else if (this.game.state === _STATE_EXHAUSTED) {
                    this.components.forEach(component => component.exhausted(this.game));
                } else if (this.game.state === _STATE_EXPIRED) {
                    this.components.forEach(component => component.expired(this.game));
                } else if (this.game.state === _STATE_WON) {
                    this.components.forEach(component => component.won(this.game));
                }
            }
        }

        class GameUiComponent {
            constructor() {
            }
            _resetElement(element) {
                while (element.firstChild) {
                    element.removeChild(element.lastChild);
                }
            }
        }

        class LevelUiComponent extends GameUiComponent {
            constructor() {
                super();
            }
            started(game) {
                this._element(game);
            }
            next(game) {
                this._element(game);
            }
            solving(game) {
            }
            solved(game) {
            }
            exhausted(game) {
            }
            expired(game) {
            }
            won(game) {
            }
            _element(game) {
                const element = document.getElementById('game-level');
                element.innerText = game.level;
            }
        }

        class TimeUiComponent extends GameUiComponent {
            constructor() {
                super();
            }
            started(game) {
                this._element(game.remaining);
            }
            next(game) {
                this._element(game.remaining);
            }
            solving(game) {
                this._element(game.remaining);
            }
            solved(game) {
                this._element(game.remaining);
            }
            exhausted(game) {
                this._element(game.remaining);
            }
            expired(game) {
                this._element(game.remaining);
            }
            won(game) {
                this._element(game.remaining);
            }
            _element(seconds) {
                const element = document.getElementById('game-time');
                element.innerText = seconds;
            }
        }

        class ScoreUiComponent extends GameUiComponent {
            constructor() {
                super();
            }
            started(game) {
                this._element(game);
            }
            next(game) {
            }
            solving(game) {
                this._element(game);
            }
            solved(game) {
                this._element(game);
            }
            exhausted(game) {
            }
            expired(game) {
            }
            won(game) {
                this._element(game);
            }
            _element(game) {
                const element = document.getElementById('game-score');
                element.innerText = game.score;
            }
        }

        class MessageUiComponent extends GameUiComponent {
            constructor() {
                super();
            }
            started(game) {
                let message = 'Welcome! Guess the numeric code...';
                this._container(message);
            }
            next(game) {
                let message = 'Cool! Try guessing this code...';
                this._container(message);
            }
            solving(game) {
                if (game.round.attempts > 0) {
                    let remaining = 5 - game.round.attempts;
                    let attempts = (remaining === 1) ? ' attempt ' : ' attempts ';
                    let message = 'Nope! ' + remaining + attempts + 'remaining...';
                    this._container(message);
                }
            }
            solved(game) {
                let message = 'Solved!';
                this._container(message, 'Next', '_actionNext()');
            }
            exhausted(game) {
                let message = 'No more attempts... You lose!';
                this._container(message, 'Start', '_actionRestart()');
            }
            expired(game) {
                let message = 'Out of time... You lose!';
                this._container(message, 'Start', '_actionRestart()');
            }
            won(game) {
                let message = 'You won!';
                this._container(message, 'Start', '_actionRestart()');
            }
            _container(message, label, action) {
                // Reset
                let container = document.getElementById('container-message');
                this._resetElement(container);
                // Message
                let pElement = document.createElement('p');
                pElement.innerText = message;
                container.appendChild(pElement);
                // Button
                if (label && action) {
                    let bElement = document.createElement('button');
                    bElement.innerText = label;
                    bElement.setAttribute('onclick', action);
                    container.appendChild(bElement);
                }
            }
        }

        class GuessUiComponent extends GameUiComponent {
            constructor() {
                super();
            }
            started(game) {
                this._container(game, false);
            }
            next(game) {
                this._container(game, false);
            }
            solving(game) {
                this._container(game, false);
            }
            solved(game) {
                this._container(game, true);
            }
            exhausted(game) {
                this._container(game, true);
            }
            expired(game) {
                this._container(game, true);
            }
            won(game) {
                this._container(game, true);
            }
            _container(game, over) {
                // Reset
                let container = document.getElementById('guess-container');
                this._resetElement(container);
                // Blocks
                let i = 0;
                let rows = Math.ceil(game.round.length / 5);
                for (let r = 1; r <= rows; r++) {
                    let rowElement = document.createElement('div');
                    rowElement.className = 'row';
                    container.append(rowElement);
                    let remaining = (5 * r) - game.round.length;
                    let columns = (remaining > 0) ? (5 - remaining) : 5;
                    for (let c = 0; c < columns; c++) {
                        let blockElement = this._block(game.round, i, over);
                        rowElement.append(blockElement);
                        i += 1;
                    }
                }
            }
            _block(round, block, over) {
                // Choice
                let choice = round.choices[block];
                let ham = choice.ham;
                let value = over ? round.answer[block] : choice.value;
                // Block
                let blockElement = document.createElement('div');
                blockElement.id = 'g-' + block;
                blockElement.className = 'row_block';
                blockElement.style.fontWeight = 'bold';
                blockElement.style.background = 'white';
                blockElement.style.color = 'black';
                if (ham === 'H') {
                    blockElement.style.background = "green";
                    blockElement.style.color = "white";
                }
                blockElement.style.padding = '15px';
                blockElement.style.margin = '2px';
                blockElement.style.borderRadius = '5px';
                blockElement.style.borderColor = null;
                if (over) {
                    blockElement.style.borderColor = "black";
                } else {
                    let onclick = '_actionFocus(' + block + ')';
                    blockElement.setAttribute('onclick', onclick);
                    if ((block !== 0) && (block === round.focus)) {
                        blockElement.style.borderColor = "black";
                    }
                }
                // Value
                let valueElement = document.createElement('span');
                valueElement.id = 'gv-' + block;
                valueElement.innerText = (value !== -1) ? value : null;
                blockElement.append(valueElement);
                // Hint
                let hintElement = document.createElement('div');
                hintElement.id = 'gh-' + block;
                hintElement.innerText = (choice.hint !== -1) ? choice.hint : null;
                hintElement.style.visibility = 'hidden';
                if (choice.hint !== -1) {
                    if (ham === 'A') {
                        hintElement.style.background = "orange";
                        hintElement.style.color = "white";
                        hintElement.style.visibility = 'visible';
                    } else if (ham === 'M') {
                        hintElement.style.background = "red";
                        hintElement.style.color = "white";
                        hintElement.style.visibility = 'visible';
                    }
                }
                blockElement.append(hintElement);
                return blockElement;
            }
        }

        class HintUiComponent extends GameUiComponent {
            constructor() {
                super();
            }
            started(game) {
                this._refresh(game.round);
            }
            next(game) {
                this._refresh(game.round);
            }
            solving(game) {
                this._refresh(game.round);
            }
            solved(game) {
            }
            exhausted(game) {
            }
            expired(game) {
            }
            won(game) {
            }
            _refresh(round) {
                // Same
                let hintElement = document.getElementById('hint-same');
                hintElement.innerText = round.hint.same;
                let progressElement = document.getElementById('same');
                if (round.hint.same === round.match.same) {
                    progressElement.innerHTML = '&#10003';
                    progressElement.style.color = 'green';
                } else {
                    let remaining = round.hint.same - round.match.same;
                    progressElement.innerHTML = '&#10007'+' '+remaining;
                    progressElement.style.color = 'red';
                }
                // Above
                hintElement = document.getElementById('hint-above');
                hintElement.innerText = round.hint.above;
                progressElement = document.getElementById('down');
                if (round.hint.below === round.match.down) {
                    progressElement.innerHTML = '&#10003';
                    progressElement.style.color = 'green';
                } else {
                    let remaining = round.hint.below - round.match.down;
                    progressElement.innerHTML = '&#10007'+' '+remaining;
                    progressElement.style.color = 'red';
                }
                // Below
                hintElement = document.getElementById('hint-below');
                hintElement.innerText = round.hint.below;
                progressElement = document.getElementById('up');
                if (round.hint.above === round.match.up) {
                    progressElement.innerHTML = '&#10003';
                    progressElement.style.color = 'green';
                } else {
                    let remaining = round.hint.above - round.match.up;
                    progressElement.innerHTML = '&#10007'+' '+remaining;
                    progressElement.style.color = 'red';
                }
                // Total
                hintElement = document.getElementById('hint-total');
                hintElement.innerText = round.hint.total;
                progressElement = document.getElementById('total');
                if (round.hint.total === round.match.total) {
                    progressElement.innerHTML = '&#10003';
                    progressElement.style.color = 'green';
                } else {
                    let remaining = round.hint.total - round.match.total;
                    progressElement.innerHTML = '&#10007'+' '+remaining;
                    progressElement.style.color = 'red';
                }
            }
        }

        class ChooseUiComponent extends GameUiComponent {
            constructor() {
                super();
            }
            started(game) {
                this._container(game);
            }
            next(game) {
                this._container(game);
            }
            solving(game) {
                this._container(game);
            }
            solved(game) {
                let container = document.getElementById('action-container');
                container.hidden = true;
            }
            exhausted(game) {
                let container = document.getElementById('action-container');
                container.hidden = true;
            }
            expired(game) {
                let container = document.getElementById('action-container');
                container.hidden = true;
            }
            won(game) {
                let container = document.getElementById('action-container');
                container.hidden = true;
            }
            _container(game) {
                // Reset
                let container = document.getElementById('action-container');
                this._resetElement(container);
                container.hidden = false;
                // Choices
                let i = 0;
                for (let r = 0; r < 2; r++) {
                    let divElement = document.createElement('div');
                    for (let c = 0; c < 6; c++) {
                        if ((r < 1) || (c < 4)) {
                            let choiceElement = document.createElement('button');
                            choiceElement.type = 'button';
                            choiceElement.innerText = i;
                            choiceElement.style.fontSize = '20px';
                            choiceElement.style.border = 'none';
                            choiceElement.style.background = '#898D8D';
                            choiceElement.style.fontWeight = 'bold';
                            choiceElement.style.color = 'white';
                            choiceElement.style.margin = '2px';
                            choiceElement.style.borderRadius = '5px';
                            let onclick = '_actionChoose("' + i + '")';
                            choiceElement.setAttribute('onclick', onclick);
                            divElement.appendChild(choiceElement);
                            i += 1;
                        }
                        if ((r === 1) && (c === 4)) {
                            let choiceElement = document.createElement('button');
                            choiceElement.id = 'choice-enter';
                            choiceElement.type = 'button';
                            choiceElement.innerText = 'Enter';
                            choiceElement.style.fontSize = '20px';
                            choiceElement.style.border = 'none';
                            choiceElement.style.background = '#898D8D';
                            choiceElement.style.fontWeight = 'bold';
                            choiceElement.style.color = 'white';
                            choiceElement.style.margin = '2px';
                            choiceElement.style.borderRadius = '5px';
                            let onclick = '_actionGuess()';
                            choiceElement.setAttribute('onclick', onclick);
                            choiceElement.hidden = this._hide(game.round);
                            divElement.appendChild(choiceElement);
                        }
                    }
                    container.appendChild(divElement);
                }
            }
            _hide(round) {
                let checked = 0;
                // Same
                if (round.hint.same === round.match.same) {
                    checked += 1;
                }
                // Above
                if (round.hint.below === round.match.down) {
                    checked += 1;
                }
                // Below
                if (round.hint.above === round.match.up) {
                    checked += 1;
                }
                // Total
                if (round.hint.total === round.match.total) {
                    checked += 1;
                }
                return (checked !== 4);
            }
        }

        class OutcomeUiComponent extends GameUiComponent {
            constructor() {
                super();
            }
            started(game) {
                this._container(game);
            }
            next(game) {
                this._container(game);
            }
            solving(game) {
                this._container(game);
            }
            solved(game) {
            }
            exhausted(game) {
            }
            expired(game) {
            }
            won(game) {
            }
            _container(game) {
                // Reset
                let container = document.getElementById('container-history');
                this._resetElement(container);
                // Previous
                for (let o = 0; o < game.round.outcomes.length; o++) {
                    let outcome = game.round.outcomes[o];
                    this._previous(outcome, container);
                }
            }
            _previous(outcome, container) {
                let divElement = document.createElement('div');
                divElement.style.padding = '5px';
                container.appendChild(divElement);
                let gArray = outcome.guess.split("");
                let hCode = outcome.ham;
                let i = 0;
                for (let j = 0; j < gArray.length; j++) {
                    let spanElement = document.createElement('span');
                    spanElement.innerText = gArray[j];
                    spanElement.style.borderStyle = 'solid';
                    spanElement.style.fontWeight = 'bold';
                    spanElement.style.padding = '2px';
                    spanElement.style.margin = '2px';
                    spanElement.style.borderRadius = '5px';
                    let ham = Utils.ham(hCode, j);
                    if (ham === 'H') {
                        spanElement.style.borderColor = 'black';
                        spanElement.style.background = "green";
                        spanElement.style.color = "white";
                    } else if (ham === 'A') {
                        spanElement.style.borderColor = 'black';
                        spanElement.style.background = "orange";
                        spanElement.style.color = "white";
                    }
                    if ((i > 0) && ((i % 5) === 0)) {
                        let separatorElement = document.createElement('span');
                        separatorElement.innerText = '-';
                        divElement.appendChild(separatorElement);
                    }
                    divElement.appendChild(spanElement);
                    i += 1;
                }
            }
        }

        class App {

            constructor() {
                this.game = new Game(1, _actionTick, _actionExpired);
                this.gameUi = new GameUi(this.game);
            }

            refresh() {
                this.gameUi.update();
            }

            focus(choice) {
                if (this.game.refocus(choice)) {
                    this.gameUi.update();
                }
            }

            choose(value) {
                this.game.choice(value);
                this.gameUi.update();
            }

            guess() {
                this.game.guess();
                if (this.game.state === _STATE_WON) {
                    _saveStats();
                } else if (this.game.state === _STATE_SOLVED) {
                    _saveStats();
                }
                this.gameUi.update();
            }

            next() {
                this.game.next();
                this.gameUi.update();
            }

            restart() {
                this.game = new Game(this.game.id+1, _actionTick, _actionExpired);
                this.gameUi = new GameUi(this.game);
                this.gameUi.update();
            }

        }

        const app = new App();

        function _initPage() {
            app.refresh();
        }

        function _actionTick() {
            app.refresh();
        }

        function _actionExpired() {
            app.refresh();
        }

        function _actionFocus(choice) {
            app.focus(choice);
        }

        function _actionChoose(value) {
            app.choose(value);
        }

        function _actionGuess() {
            app.guess();
        }

        function _actionNext() {
            app.next();
        }

        function _actionRestart() {
            app.restart();
        }

        function _openModal(message) {
            let messageElement = document.getElementById('modal-message');
            messageElement.innerText = message;
            let element = document.getElementById('myModal');
            element.style.display = "block";
        }

        function _closeModal() {
            let element = document.getElementById('myModal');
            element.style.display = "none";
        }

        function _dialogShow(id) {
            document.getElementById(id).showModal();
        }

        function _dialogClose(id) {
            document.getElementById(id).close();
        }

    </script>
    <style>
        .container {
            display:flex;
            justify-content:space-between;
            align-items:center;
        }
        #navbar button{
            display:inline-block;
        }
    </style>
</head>
<body onload="_initPage()">

<header class="container" style="display: flex;">
    <h1>Cronkle</h1>
    <nav id="navbar">
        <button onclick="_dialogStats();" type="button" style="font-size: 20px; background-color: dodgerblue;">#</button>
        <button onclick="_dialogShow('dialog-help');" type="button" style="font-size: 20px; background-color: dodgerblue;">?</button>
    </nav>
</header>


<div class="grid-container">

    <div id="section-level" class="item1">
        <h2>Level: <span id="game-level">0</span></h2>
    </div>

    <div id="section-time" class="item8">
        <h2>Time: <span id="game-time">0</span></h2>
    </div>

    <div id="section-score" class="item2">
        <h2>Score: <span id="game-score">0</span></h2>
    </div>

    <div id="section-guess" class="item3">
        <div id="guess-container">
        </div>
    </div>

    <div id="section-hint" class="item4">
        <div id="container-hint" style="padding: 5px;">
            <span id="hint-same">&nbsp;</span> <span class="hint_circle">&equals;</span> <span id="same">&nbsp;</span> &#9474;
            <span id="hint-below">&nbsp;</span> <span class="hint_circle">&lt;</span> <span id="down">&nbsp;</span> &#9474;
            <span id="hint-above">&nbsp;</span> <span class="hint_circle">&gt;</span> <span id="up">&nbsp;</span> &#9474;
            <span id="hint-total">&nbsp;</span> <span class="hint_circle">&plus;</span> <span id="total">&nbsp;</span>
        </div>
    </div>

    <div id="container-action" class="item5">
        <div id="action-container">
        </div>
    </div>

    <div id="section-history" class="item6">
        <div id="container-history">
        </div>
    </div>

    <div id="section-message" class="item7">
        <div id="container-message"></div>
    </div>

</div>

<!-- The Modal -->
<div id="myModal" class="modal">

    <!-- Modal content -->
    <div class="modal-content">
        <span class="close" onclick="_closeModal();">&times;</span>
        <p id="modal-message"></p>
    </div>

</div>

<dialog id="dialog-help">
    <button style="float: right;" onclick="_dialogClose('dialog-help');">Close</button>
    <h3>How To Play</h3>
    Guess the numeric code to move onto the next level.
    <ul>
        <li>The code is broken down into number blocks.</li>
        <li>Blocks change color to show how close the guess was.</li>
        <li>The first block is always solved (green).</li>
        <li>All blocks other than green are unsolved.</li>
        <li>Maximum of 5 guesses per level.</li>
    </ul>
    <h4>Examples</h4>
    <div class="row">
        <div class="row_block_help" style="border-radius: 0; border: 1px solid black; color: white; background-color: green;">3</div>
        <div class="row_block_help" style="border-radius: 5px; border-color: black; color: white; background-color: orange;">2</div>
        <div class="row_block_help" style="border-radius: 0; border: 1px solid black;">7</div>
    </div>
    <ul>
        <li>The first block (<b>3</b>) is always solved (green).</li>
        <li><b>2</b> is in the code but the wrong block (orange).</li>
        <li><b>2</b> is the current block in focus (wider border).</li>
        <li><b>7</b> is not in any <i>unsolved</i> blocks (white).</li>
    </ul>
    <div class="row">
        <div class="row_block_help" style="border-radius: 0; border: 1px solid black; color: white; background-color: green;">3</div>
        <div class="row_block_help" style="border-radius: 5px; border-color: black;">8</div>
        <div class="row_block_help" style="border-radius: 0; border: 1px solid black; color: white; background-color: green;">2</div>
    </div>
    <ul>
        <li><b>2</b> has now been guessed correctly (green).</li>
        <li><b>8</b> is also not in any unsolved blocks (white).</li>
        <li><b>8</b> is the current block in focus (wider border).</li>
    </ul>
    <h4>Hint Bar</h4>
    Use the hint bar to help guess unsolved blocks.
    <ul>
        <li><span class="hint_circle">&equals;</span> Number of other blocks matching first.</li>
        <li><span class="hint_circle">&lt;</span> Number of other blocks less than first.</li>
        <li><span class="hint_circle">&gt;</span> Number of other blocks more than first.</li>
        <li><span class="hint_circle">&plus;</span> Total sum of all numbers in the code.</li>
    </ul>
    <h4>Examples</h4>
    <div style="width: 100%; text-align: center;">
        1 <span class="hint_circle">&equals;</span> <span style="color: green;">&#10003;</span>
    </div>
    <ul>
        <li>Exactly 1 other block matches the first.</li>
        <li>The green tick indicates current guess aligns with hint.</li>
    </ul>
    <div style="width: 100%; text-align: center;">
        2 <span class="hint_circle">&gt;</span> <span style="color: red;">&#10007;1</span>
    </div>
    <ul>
        <li>Exactly 2 other blocks are more than first.</li>
        <li>The red cross indicates that 1 more other block needs to align with hint.</li>
    </ul>
    <p>The game will not let you <b><i>Enter</i></b> a guess without all four hints aligned.</p>
</dialog>

<dialog id="dialog-stats">
    <button style="float: right;" onclick="_dialogClose('dialog-stats');">Close</button>
    <h3>Statistics</h3>
    <p>These are <i>never shared</i> and <i>only</i> stored locally on your device.</p>
    <h4>Highest Achievement</h4>
    <p>It's the best you have done, at least on this device.</p>
    <div><span style="font-weight: bolder">&#127298; : </span> <span id="stats-score">0</span> <span style="float: right">(Score)</span></div>
    <div><span style="font-weight: bolder">&#127299; : </span> <span id="stats-time">0</span> <span style="float: right">(Time)</span></div>
    <div><span style="font-weight: bolder">&#127280; : </span> <span id="stats-attempts">0</span> <span style="float: right">(Attempts)</span></div>
    <div><span style="font-weight: bolder">&#127297; : </span> <span id="stats-level">0</span> <span style="float: right">(Round)</span></div>
    <p id="stats-message" style="font-style: italic;"></p>
</dialog>

<script>

    function _dialogStats() {
        _refreshStats();
        _dialogShow('dialog-stats');
    }

    function _refreshStats() {
        let previousStats = _parseStats();
        let element = document.getElementById('stats-score');
        element.innerText = previousStats.score;
        element = document.getElementById('stats-time');
        element.innerText = previousStats.time;
        element = document.getElementById('stats-attempts');
        element.innerText = previousStats.attempts;
        element = document.getElementById('stats-level');
        element.innerText = previousStats.level;
        element = document.getElementById('stats-message');
        if (previousStats.level === 0) {
            element.innerText = 'Time to solve at least one level, hmm!?';
        } else if (previousStats.level === 10) {
            element.innerText = 'Wow! Can you get a better score?';
        } else {
            element.innerText = 'Nice! Can you beat level '+previousStats.level+'?'
        }
    }

    function _saveStats() {
        // Current
        let currentStats = {};
        if (app.game.round.solved()) {
            currentStats.score = app.game.score;
            currentStats.time = app.game.time;
            currentStats.attempts = app.game.attempts;
            currentStats.level = app.game.level;

        }
        // Update if improved
        if (currentStats.level) {
            let improved = false;
            let previousStats = _parseStats();
            if (currentStats.level === previousStats.level) {
                if (currentStats.score > previousStats.score) {
                    improved = true;
                }
            } else if (currentStats.level > previousStats.level) {
                improved = true;
            }
            if (improved) {
                localStorage.setItem('cronkle-stats', JSON.stringify(currentStats));
            }
        }
    }

    function _parseStats() {
        let r = { score: 0, time: 0, attempts: 0, level: 0 };
        let json = localStorage.getItem('cronkle-stats');
        if (json) { r = JSON.parse(json); }
        return r;
    }

</script>
</body>
</html>
